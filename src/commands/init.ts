import { existsSync, mkdirSync } from 'node:fs'
import path from 'node:path'
import { Readable } from 'node:stream'
import { writeFile } from 'node:fs/promises'
import { type ReadableStream } from 'node:stream/web'
import { Command } from 'commander'
import { cancel, outro, text, group, multiselect, spinner } from '@clack/prompts'
import chalk from 'chalk'
import { handleError } from '@/utils/handleError.js'
import { DEFAULT_SEO_SCHEMA, FIELDS_WITHOUT_AI } from '@/constants.js'
import { generateGlobalSEO, generateIconDefinition } from '@/utils/ai.js'
import { generateIcon } from '@/utils/replicate.js'
import { getPackageJson } from '@/utils/getPackageJson.js'

export const init = new Command()
  .name('init')
  .description('generate seo')
  .action(async () => {
    try {
      const result = await group(
        {
          description: () =>
            text({
              message: 'Enter a brief description of your project',
              placeholder: 'page to generate readmes using ai',
              validate(value) {
                const descriptionLength = value.trim().length
                if (descriptionLength === 0) return `Description is required!`
                if (descriptionLength < 10) return `Description must be at least 10 characters!`
              }
            }),
          seoItems: () =>
            multiselect({
              message: `The following SEO items are going to be generated for your project:`,
              options: [
                { value: 'title', label: 'Title', hint: 'recommended' },
                { value: 'description', label: 'Description', hint: 'recommended' },
                { value: 'keywords', label: 'Keywords', hint: 'recommended' },
                { value: 'icons', label: 'Icons', hint: 'recommended' },
                { value: 'openGraph', label: 'Open Graph', hint: 'recommended' },
                { value: 'metadataBase', label: 'URL prefix for metadata fields' },
                { value: 'twitter', label: 'Twitter', hint: 'recommended' },
                { value: 'applicationName', label: 'Application Name' }, // from package.json
                { value: 'authors', label: 'Authors of the web page' }, // from package.json
                { value: 'generator', label: 'The generator used' },
                { value: 'creator', label: 'Creator of the web' }, // from package.json
                { value: 'publisher', label: 'Publisher of the document' }, // from package.json
                { value: 'robots', label: 'Robots settings for the document' },
                { value: 'category', label: 'Category meta name property' },
                { value: 'themeColor', label: 'Theme Color for the document' }, // https://nextjs.org/docs/app/api-reference/functions/generate-viewport
                { value: 'colorSchema', label: 'Color Scheme for the document' }
              ],
              initialValues: ['title', 'description', 'keywords', 'openGraph', 'icons'],
              required: true
            })
        },
        {
          onCancel: ({ results }) => {
            // console.log(results)
            cancel('Operation cancelled.')
            process.exit(0)
          }
        }
      )

      const { description, seoItems } = result

      const fieldsWithAI = seoItems.filter((field) => !FIELDS_WITHOUT_AI.includes(field))
      const fieldsToInclude = fieldsWithAI.reduce((acc, field) => ({ ...acc, [field]: true }), {})
      const seoSchema = DEFAULT_SEO_SCHEMA.pick(fieldsToInclude)

      const s = spinner()
      s.start('Generating SEO data...')

      let SEO_METADATA = undefined

      const seo = await generateGlobalSEO({
        description,
        seoSchema
      })

      console.log(seo)

      // Adding SEO metadata generated by LLM
      SEO_METADATA = {
        ...seo
      }

      s.stop('SEO generated ðŸš€!')

      if (seoItems.includes('icons')) {
        const s = spinner()
        s.start('Generating icons...')

        const iconDefinition = await generateIconDefinition({
          prompt: description
        })

        const iconUrl = await generateIcon({
          iconDefinition
        })

        console.log(iconUrl)

        const cwd = path.resolve(process.cwd())
        const seoDirectory = `public/seo/icons`
        const publicDirectory = `${cwd}/${seoDirectory}`

        if (!existsSync(publicDirectory)) {
          mkdirSync(publicDirectory, {
            recursive: true
          })
        }

        const response = await fetch(iconUrl)
        const body = Readable.fromWeb(response.body as ReadableStream<any>)
        const fileIconPath = path.join(publicDirectory, 'icon.png')
        await writeFile(fileIconPath, body)
        const fileAppleIconPath = path.join(publicDirectory, 'apple-icon.png')
        await writeFile(fileAppleIconPath, body)
        s.stop(`Icons stored in ${chalk.green(seoDirectory)}`)

        const icons = {
          icon: '/seo/icons/icon.png',
          apple: '/seo/icons/apple-icon.png'
        }

        SEO_METADATA = {
          ...SEO_METADATA,
          icons
        }
      }

      if (seoItems.includes('applicationName')) {
        const packageInfo = getPackageJson()
        const appName = packageInfo.name ?? 'wonderful-app'

        SEO_METADATA = {
          ...SEO_METADATA,
          applicationName: appName
        }
      }

      if (seoItems.includes('authors')) {
        const packageInfo = getPackageJson()
        const authors = packageInfo.author
          ? typeof packageInfo.author === 'string'
            ? { name: packageInfo.author, url: `https://github.com/${packageInfo.author}` }
            : {
                name: packageInfo.author?.name ?? '@seodev',
                url: packageInfo.author?.url ?? 'https//github.com/seodev'
              }
          : '@seodev'

        SEO_METADATA = {
          ...SEO_METADATA,
          authors
        }
      }

      if (seoItems.includes('creator')) {
        const packageInfo = getPackageJson()
        const creator = packageInfo.author
          ? typeof packageInfo.author === 'string'
            ? packageInfo.author
            : packageInfo.author?.name ?? '@seodev'
          : '@seodev'

        SEO_METADATA = {
          ...SEO_METADATA,
          creator
        }
      }

      if (seoItems.includes('publisher')) {
        SEO_METADATA = {
          ...SEO_METADATA,
          publisher: 'seo-AI'
        }
      }

      if (seoItems.includes('twitter') && SEO_METADATA) {
        const twitterGraphImage = [
          {
            url: '/seo/banner/og.png',
            with: 1200,
            height: 675,
            alt: 'Seo AI'
          }
        ]

        SEO_METADATA = {
          ...SEO_METADATA,
          twitter: {
            // @ts-ignore
            ...SEO_METADATA.twitter,
            images: twitterGraphImage
          }
        }
      }

      if (seoItems.includes('openGraph') && SEO_METADATA) {
        const graphImage = [
          {
            url: '/seo/banner/og.png',
            with: 1200,
            height: 675,
            alt: 'Seo AI'
          }
        ]

        if (SEO_METADATA) {
          SEO_METADATA = {
            ...SEO_METADATA,
            openGraph: {
              // @ts-ignore
              ...SEO_METADATA.openGraph,
              images: graphImage
            }
          }
        }
      }

      outro(`You're all set!`)

      console.log(SEO_METADATA)
    } catch (error) {
      handleError(error)
    }
  })
